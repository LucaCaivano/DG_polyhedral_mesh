function [output] = MAIN_El(testcase,varargin)
%
% MAIN          : solution of the elastodynamics equations in 2d polygonal domain
% FEATURES:     - arbitrary high order polynomials
%               - heterogeneous materials
%               - polygonal meshes (generated by Polymesher agglomerated by Metismex)
%               - homogeneous Neumann boundary conditions
%               - inhomogeneous Dirichlet boundary conditions
%               - implicit time integration scheme
%               - damping frequency porportional
%
%
% INPUT:
%       testcase : Name of the input structure in dati.m
%       varargin : For verification test case is a set of one or two
%                  numbers. The first is the number of initial elements,
%                  the second is the number of refinements (example of
%                  input: MAIN('TestDirichlet', 2, 3)).
%                  Same for application test but the refinement step is
%                  always 1
%
%
% OUTPUT:
%       output   : structure containing the fields
%                  E_L2 - error in the L2 norm
%                  G_L2 - error in the H1 seminorm
%                  E_H1 - error in the H1 norm
%                  N    - number of elements
%                  hmin - minimum mesh size
%                  hmax - maximum mesh size
%                  region - info about the mesh
%                  neighbour - info about the mesh
%                  femregion - info about finite element solution
%
% EXAMPLE OF USAGE :
%           [output] = MAIN('Square',10)
%           [output] = MAIN('Corona',10)
%           [output] = MAIN('Plate',10)



% load dati structure
Dati = dati(testcase);
Dati.nqn = 2*Dati.fem + 1; %number of quadrature GL nodes

if (strcmp(Dati.type,'verification'))
    
    disp(['Verication test case ...',testcase]);
    N = varargin{1};
    % infos about the mesh
    disp(['Number of Polygonal Elements ... ', num2str(N)]);
    
    if size(varargin,2) == 1
        refinement_step = 4;
    else
        refinement_step = varargin{2};
    end
    % infos about the mesh
    disp(['solution computed for ', num2str(refinement_step),' refinement level']);
    
else
    
    % load external mesh
    filemate = Dati.MeshName;
    load([filemate,'.mat']);
    % infos about the mesh
    disp(['Number of Polygonal Elements ... ', num2str(N)]);
    refinement_step = 1;
    
end


for rl = 1 : refinement_step
    
    if (strcmp(Dati.type,'verification'))
        
        % only for square domains -- cartesian mesh
        h = (Dati.domain(2)-Dati.domain(1))/N;
        [X1,Y1] = meshgrid([h/2 : h : Dati.domain(2)], [h/2 : h : Dati.domain(4)]);  % middle points of the mesh elements
        
        %for plate
        %[X1,Y1] = meshgrid([h/2 : h : 2.6], [h/2 : h : 1.0]);
        
        P = [[X1(:)], [Y1(:)]];
        Nel = size(P,1);
        
        %Square with quadratic mesh
        [region] = generate_mesh(Dati,Dati.domain,@MbbDomain,Nel,100, P); %If varargin{1}=2 there are 4 subsquares of [0,1]^2
        
        %Square with polytopic mesh
        %[region] = generate_mesh(Dati,Dati.domain,@MbbDomain,Nel,100);
        
        %Corona
        %[region] = generate_mesh_corona(Dati,Dati.domain,@CircleDomain,Nel,100);
        
        %Plate
        %[region] = generate_mesh(Dati,Dati.domain,@MichellDomain,Nel,100);
        
    end
    
    %region's fields:
    %nedges: nedges[i] contains the number of edges of the i-th element
    %BBox: bounding box
    %ne: number of elements
    %coord: set of points' coordinates
    %coords_element: same as coord but in groups, one for each element
    %connectivity: a set of ne vectors in which we find the enumeration
    % of the internal and boundary nodes (same order as
    % coord)
    %area: set of ne values representing the elements' area
    %max_kb: used only for penality calibration
    
    hmin = min(sqrt((region.BBox(:,1)-region.BBox(:,2)).^2 + (region.BBox(:,3)-region.BBox(:,4)).^2));
    hmax = max(sqrt((region.BBox(:,1)-region.BBox(:,2)).^2 + (region.BBox(:,3)-region.BBox(:,4)).^2));
    disp(['Minimum mesh size ...', num2str(hmin)]);
    disp(['Maximum mesh size ...', num2str(hmax)]);
    
    % connectivity
    disp('Making connectivity ... ');
    [neighbour] = neighbours(Dati,region,hmin);
    disp('Done');
    
    %neighbour has 3 fields:
    %nedges: same as region.nedges
    %neigh: neigh{i} contains the list of the indexes of the adjacent elements (counter clockwise starting from the bottom)
    %neighedges: neghbour's edges enumeration

    % femregion
    disp('Making femregion ... ');
    [femregion] = create_dof(Dati,region);
    
    %femregion has several fields:
    %fem: degree of the polynomials involved
    %nedges: same as neighbour.nedges
    %nln: number of degrees of freedom in a single element
    %ndof: number of total degrees of freedom
    %ne: number of elements
    %nqn: number of quadrature nodes per element
    %coord: same as region.coord (set of mesh points' coords)
    %BBox: same as region.BBox
    %coords_element: same as region.coords_element
    %connectivity: same as region.connectivity
    %area: same a region.area
    %max_kb: same as region.max_kb
    %E_tag: used to evaluate rho, vs and vp
    
    if (strcmp(Dati.type,'verification'))
        femregion.E_tag(1:femregion.ne) = 1;
    else
        femregion.E_tag = E_tag;
    end
    disp('Done');
    
    % plot mesh with boundary conditions
    disp('Plotting the ploygonal mesh');
    if (strcmp(Dati.type,'verification'))
        subplot(1,4,rl)
        plot_poly_mesh(Dati,region, neighbour);
        
    else
        plot_poly_mesh(Dati,region, neighbour);
    end
    disp('Done');
    
    % saving output
    output.hmin(rl) = hmin;
    output.hmax(rl) = hmax;
    output.region(rl) = region;
    output.neighbour(rl) = neighbour;
    output.femregion(rl) = femregion;
    output.Dati(rl) = Dati;
    
    %building of  stiffness and mass matrix
    disp('Making Mass and Stiffness matrices');
    [Matrices] = matrix2D_El(femregion,neighbour,Dati);
    V_el=Matrices.V;
    IT_el=Matrices.IT;
    S=Matrices.S;
    K_el=V_el - Dati.theta*IT_el - IT_el' + S;
    disp('Done');
    
    dim=2*femregion.ndof;
    f = evaluate_f(neighbour,femregion,Dati,0.0);
    f = evaluate_boundary_conditions(f,neighbour,femregion,Dati,0.0);  %rhs
    u_el=K_el\f;
    
    %plot of the solution
    v2 = zeros(size(u_it));
    [G] = SaveSolution(Dati,femregion,u_it,v2,0);
    filename = [testcase,'_RefLev_', '0','_elastic_','0','.txt'];
    
    fid = fopen(filename,'w');
    for i = 1 : size(G,1)
        fprintf(fid,'%8.7e,%8.7e,%8.7e,%8.7e,%8.7e,%8.7e', G(i,:));
        fprintf(fid,'\n');
    end
    fclose(fid);
    filename = [testcase,'_RefLev_', '0','_elastic_','0','.txt']; %(by me)
    sol = load(filename);
    % plot_poly_solution(output.Dati(end),output.region(end),sol,fig_num)
    figure()
    scatter(sol(:,1),sol(:,2),20,sol(:,3),'filled');colorbar
    title('u_x^{el}')
    figure()
    scatter(sol(:,1),sol(:,2),20,sol(:,4),'filled');colorbar
    title('u_y^{el}')
    figure()
    scatter(sol(:, 1), sol(:, 2), 10, sqrt(sol(:, 3).^2+sol(:, 4).^2), 'filled'), colorbar
    title('u_{tot}^{el}')
    figure()
    scatter(sol(:, 1)+sol(:, 3), sol(:, 2)+sol(:, 4), 10, sqrt(sol(:, 3).^2+sol(:, 4).^2), 'filled'), colorbar
    title('elastic strain')
    
    if (strcmp(Dati.type,'verification'))
%       v2 = (u2-u0)/(2*dt);
%       [G] = SaveSolution(Dati,femregion,u2,v2,t);
        
        [E_L2,G_L2,E_H1] = compute_errors(Dati,femregion,u_el,0.0);
        output.E_L2(rl) = E_L2;
        output.G_L2(rl) = G_L2;
        output.E_H1(rl) = E_H1;
        output.N(rl) = N;
        
        %double the elements
        N = N*2;
    end
    
    if (strcmp(Dati.type,'verification'))
        convergence(output.hmin,output.E_L2,output.G_L2,1,Dati.fem);
        convergence(output.hmin,output.E_L2,output.G_L2,2,Dati.fem);
    end
    
    
end